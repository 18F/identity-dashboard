# This expects a file name that contains the output generated by
# the Extract/ExtractsController classes
class ServiceProviderImporter
  attr_reader :file_name, :data, :teams, :service_providers
  attr_accessor :dry_run

  def initialize(file_name)
    @file_name = file_name
  end

  def run
    validate_file unless data
    create_available_teams unless teams
    teams.concat(create_missing_teams).compact!
    normalize_service_providers unless service_providers

    errors = { service_provider_errors: service_provider_errors, team_errors: team_errors }

    return errors if service_provider_errors_any? || team_errors_any?

    save unless dry_run
    errors
  end

  def service_provider_errors_any?
    service_provider_errors.values.any? { |error| error.any? }
  end

  def team_errors_any?
    team_errors.values.any? { |error| error.any? }
  end

  private

  def extract_destination
    @extract_destination ||= Dir.mktmpdir
  end

  def validate_file
    raise ArgumentError, "File #{file_name} cannot be opened" unless File.readable?(file_name)

    begin
      File.open(file_name) do |file|
        @data = JSON.parse(file.read)
      end
    rescue JSON::ParserError
      Minitar.unpack(Zlib::GzipReader.open(file_name), extract_destination)
      File.open(File.join(extract_destination, 'extract.json')) do |f|
        @data = JSON.parse(f.read)
      end
      @from_gzip = true
    end
  end

  def normalize_service_providers
    @service_providers = data['service_providers'].map do |config|
      team_uuid = config['team_uuid']

      # Prefer an in-memory team created earlier in this run (dry_run or unsaved);
      # fall back to DB lookup; otherwise use internal team.
      team = (teams&.find { |t| t.uuid == team_uuid } || Team.find_by(uuid: team_uuid) if team_uuid)
      team ||= Team.internal_team

      config.delete 'id'

      sp = ServiceProvider.new(**config.except('team_uuid'))
      sp.team = team

      # Set the owning user as the first internal team user.
      # The portal doesn't require this column anymore, but it's still required by the schema.
      sp.user = Team.internal_team.users.first
      sp
    end
  end

  def create_available_teams
    @teams = data['teams'].uniq.map do |config|
      team = Team.new(
        uuid: config['uuid'],
        name: config['name'],
        description: config['description'],
        agency_id: config['agency_id'],
      )
      team
    end
  end

  def create_missing_teams
    data['service_providers'].map do |config|
      team_uuid = config['team_uuid']
      next unless team_uuid
      # Skip if team already exists in the DB OR is already scheduled to be created
      # in this import run (e.g. during a dry_run the in-memory @teams contains
      # new Team instances that haven't been saved yet).
      next if Team.exists?(uuid: team_uuid) || teams&.any? { |t| t.uuid == team_uuid }

      team = Team.new(
        uuid: team_uuid,
        name: "Created by importer #{team_uuid}",
        agency_id: config['agency_id'],
      )
      team
    end
  end

  def service_provider_errors
    service_providers.each_with_object({}) do |model, error_list|
      model.valid?
      logo_errors model
      error_list[model.issuer] = model.errors if model.errors.any?
    end
  end

  def team_errors
    teams.each_with_object({}) do |model, error_list|
      model.valid?
      error_list[model.uuid] = model.errors if model.errors.any?
    end
  end

  def logo_errors(sp)
    return unless sp.logo.present? && @from_gzip

    filepath = File.join(extract_destination, sp.logo)
    if !File.exist?(filepath)
      sp.errors.add(:logo_file, message: "'#{sp.logo}' is missing.")
    end
  end

  def save
    service_providers.each do |sp|
      if sp.logo.present? && @from_gzip
        logo_data = File.open(File.join(extract_destination, sp.logo))
        content_type = sp.logo.end_with?('.png') ? 'image/png' : 'image/svg'
        blob = ActiveStorage::Blob.create_and_upload!(
          io: logo_data,
          filename: sp.logo,
          content_type: content_type,
        )
        sp.logo_file.attach blob
      end
      sp.save!
    end
    teams.each &:save!
  end
end
